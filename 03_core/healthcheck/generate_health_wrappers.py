#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
generate_health_wrappers.py – Automated Health Wrapper Generator
Autor: edubrainboost ©2025 MIT License

Replaces all 384 stub health.py files with production-ready wrappers
that use the unified HealthChecker framework.
"""

import re
import sys
from pathlib import Path
from typing import Dict, List, Tuple

ROOT = Path(__file__).resolve().parents[2]

# Service configuration: maps root module to port ranges
SERVICE_CONFIG = {
    "01_ai_layer": {"base_port": 8100, "endpoint": "/health"},
    "02_audit_logging": {"base_port": 8200, "endpoint": "/health"},
    "03_core": {"base_port": 8300, "endpoint": "/health"},
    "04_deployment": {"base_port": 8400, "endpoint": "/health"},
    "05_documentation": {"base_port": 8500, "endpoint": "/health"},
    "06_data_pipeline": {"base_port": 8600, "endpoint": "/health"},
    "09_meta_identity": {"base_port": 8900, "endpoint": "/health"},
    "10_interoperability": {"base_port": 9000, "endpoint": "/health"},
}

# Shard mapping to port offsets
SHARD_OFFSETS = {
    "01_identitaet_personen": 1,
    "02_dokumente_nachweise": 2,
    "03_zugang_berechtigungen": 3,
    "04_kommunikation_daten": 4,
    "05_gesundheit_medizin": 5,
    "06_bildung_qualifikationen": 6,
    "07_familie_soziales": 7,
    "08_mobilitaet_fahrzeuge": 8,
    "09_arbeit_karriere": 9,
    "10_finanzen_banking": 10,
    "11_versicherungen_risiken": 11,
    "12_immobilien_grundstuecke": 12,
    "13_unternehmen_gewerbe": 13,
    "14_vertraege_vereinbarungen": 14,
    "15_handel_transaktionen": 15,
    "16_behoerden_verwaltung": 16,
}

def extract_service_info(health_file: Path) -> Tuple[str, str, int, str]:
    """
    Extract service configuration from health.py file path.

    Args:
        health_file: Path to health.py file

    Returns:
        Tuple of (service_name, root_module, port, endpoint)
    """
    parts = health_file.parts

    # Find root module (e.g., 01_ai_layer)
    root_module = None
    shard_name = None

    for part in parts:
        if part in SERVICE_CONFIG:
            root_module = part
        if part in SHARD_OFFSETS:
            shard_name = part

    if not root_module:
        root_module = "03_core"  # Default

    if not shard_name:
        shard_name = "01_identitaet_personen"  # Default

    # Calculate port
    config = SERVICE_CONFIG.get(root_module, {"base_port": 8000, "endpoint": "/health"})
    port = config["base_port"] + SHARD_OFFSETS.get(shard_name, 0)
    endpoint = config["endpoint"]

    # Generate service name
    service_name = f"{root_module}-{shard_name}"

    return service_name, root_module, port, endpoint

def generate_health_wrapper(service_name: str, port: int, endpoint: str) -> str:
    """
    Generate health.py wrapper content.

    Args:
        service_name: Name of the service
        port: TCP port to check
        endpoint: HTTP endpoint path

    Returns:
        Generated Python code as string
    """
    return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Health check wrapper for {service_name}
Auto-generated by SSID Health Check Framework

This module replaces the stub implementation with production-ready
readiness checks (port, HTTP, registry) per Blueprint 4.2.
"""

import sys
from pathlib import Path

# Add core module to path
ROOT = Path(__file__).resolve().parents[7]  # Go up to SSID root
CORE_PATH = ROOT / "03_core"
if str(CORE_PATH) not in sys.path:
    sys.path.insert(0, str(CORE_PATH))

from healthcheck.health_check_core import HealthChecker, run_checks

def check_health() -> bool:
    """
    Execute health checks for {service_name}.

    Returns:
        True if all checks pass, False otherwise
    """
    checkers = [
        HealthChecker(
            name="{service_name}",
            port={port},
            endpoint="{endpoint}",
            timeout=3.0
        ),
    ]

    return run_checks(checkers)

def main():
    """CLI entry point."""
    success = check_health()
    print(f"{{'{service_name}'}}: {{'PASS' if success else 'FAIL'}}")
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()
'''

def process_all_health_files() -> Dict[str, int]:
    """
    Find and update all health.py files.

    Returns:
        Dict with processing statistics
    """
    stats = {"processed": 0, "skipped": 0, "errors": 0}

    # Find all health.py files
    all_health_files = list(ROOT.glob("**/health.py"))
    print(f"Found {len(all_health_files)} total health.py files")

    # Filter to only implementation health files
    health_files = [
        f for f in all_health_files
        if "implementations" in f.parts and "api" in f.parts
    ]

    print(f"Filtered to {len(health_files)} implementation health.py files to process")

    for health_file in health_files:
        try:
            # Extract configuration
            service_name, root_module, port, endpoint = extract_service_info(health_file)

            # Generate new content
            new_content = generate_health_wrapper(service_name, port, endpoint)

            # Write to file
            health_file.write_text(new_content, encoding="utf-8")

            stats["processed"] += 1

            if stats["processed"] % 50 == 0:
                print(f"  Processed {stats['processed']} files...")

        except Exception as e:
            print(f"  Error processing {health_file}: {e}")
            stats["errors"] += 1

    return stats

def main():
    """Main entry point."""
    print("SSID Health Wrapper Generator")
    print("=" * 60)
    print(f"Root: {ROOT}")
    print()

    stats = process_all_health_files()

    print()
    print("=" * 60)
    print("Summary:")
    print(f"  Processed: {stats['processed']}")
    print(f"  Skipped:   {stats['skipped']}")
    print(f"  Errors:    {stats['errors']}")
    print()

    if stats["errors"] == 0:
        print("[OK] All health wrappers generated successfully")
        return 0
    else:
        print("[ERROR] Some errors occurred")
        return 1

if __name__ == "__main__":
    sys.exit(main())
