# SSID OPA Policy - 21_post_quantum_crypto (FUNCTIONAL v6.3)
# Auto-generated from 21_post_quantum_crypto/chart.yaml
# Mode: HONEST COMPLIANCE + ROOT-24-LOCK STRICT + SAFE-FIX
# Status: FUNCTIONAL

package ssid.21postquantumcrypto.v6_0

# FUNCTIONAL POLICY - ready = true
default ready := true

# Metadata
metadata := {
  "root": "21_post_quantum_crypto",
  "version": "v6.0",
  "status": "functional",
  "capabilities_count": 6,
  "policies_count": 3,
  "interfaces_count": 3
}

# ============================================================
# FUNCTIONAL ENFORCEMENT RULES
# ============================================================

default allow := false

# ALLOW RULE 1: Valid authenticated operations
allow {
  input.request.type == "21_post_quantum_crypto_operation"
  input.request.valid == true
  input.auth.authenticated == true
}

# ALLOW RULE 2: Read operations (less restrictive)
allow {
  input.request.type == "read"
  input.resource.root == "21_post_quantum_crypto"
  input.auth.authenticated == true
}

# ALLOW RULE 3: Capability-based operations
allow {
  input.request.type == "capability_check"
  input.capability in ["pqc_key_generation", "quantum_resistant_signatures", "lattice_based_encryption", "hash_based_signatures", "pqc_key_exchange", "hybrid_crypto_schemes"]
  input.auth.authorized == true
}

# DENY RULE 1: Missing authentication
deny[msg] {
  input.request.type == "21_post_quantum_crypto_operation"
  not input.auth.authenticated
  msg := "Authentication required for 21_post_quantum_crypto operations"
}

# DENY RULE 2: Invalid request
deny[msg] {
  input.request.type == "21_post_quantum_crypto_operation"
  input.request.valid == false
  msg := "Invalid request for 21_post_quantum_crypto - validation failed"
}

# DENY RULE 3: Missing required fields
deny[msg] {
  input.request.type == "21_post_quantum_crypto_operation"
  not input.request.action
  msg := "Missing required field: action"
}

# Policy-specific enforcement rules

# Policy: nist_pqc_only (enforcement: automated, scope: all_operations)
deny_nistpqconly[msg] {
  input.request.type == "21_post_quantum_crypto_operation"
  input.policy_check == "nist_pqc_only"
  not input.policy_compliance.nistpqconly
  msg := "Policy violation: nist_pqc_only (scope: all_operations)"
}

# Policy: key_rotation (enforcement: automated, scope: all_keys)
deny_keyrotation[msg] {
  input.request.type == "21_post_quantum_crypto_operation"
  input.policy_check == "key_rotation"
  not input.policy_compliance.keyrotation
  msg := "Policy violation: key_rotation (scope: all_keys)"
}

# Policy: quantum_safe_storage (enforcement: automated, scope: all_keys)
deny_quantumsafestorage[msg] {
  input.request.type == "21_post_quantum_crypto_operation"
  input.policy_check == "quantum_safe_storage"
  not input.policy_compliance.quantumsafestorage
  msg := "Policy violation: quantum_safe_storage (scope: all_keys)"
}

# BOUNDARY CHECK 1: Resource limits
deny[msg] {
  input.request.type == "21_post_quantum_crypto_operation"
  input.resource.size > 10485760  # 10MB limit
  msg := "Resource size exceeds limit (10MB) for 21_post_quantum_crypto"
}

# BOUNDARY CHECK 2: Rate limiting
deny[msg] {
  input.request.type == "21_post_quantum_crypto_operation"
  input.request.count > 1000  # Max 1000 requests
  msg := "Request count exceeds rate limit (1000) for 21_post_quantum_crypto"
}

# Health check
health_check := {
  "ready": ready,
  "implemented": true,
  "enforcement_enabled": true,
  "version": "v6.0",
  "root": "21_post_quantum_crypto",
  "capabilities": 6,
  "policies": 3
}
